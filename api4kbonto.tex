% This is the main latex file for the
% submission to RuleML 2015 about
% API4KB ontologies
%
\documentclass[runningheads]{llncs}
\usepackage{amsmath,amssymb,amsfonts,textcomp}
\usepackage{url}
\usepackage{cite}
\usepackage{footnote}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{rotating}
\usepackage[final]{todonotes}
%
\title{API4KP Metamodel: a Meta-API for Heterogeneous Knowledge Platforms}

\titlerunning{API4KP Metamodel}

\date{}
%
\begin{document}
%
\author{Tara Athan\inst{1}\ \ Roy Bell\inst{2} \ \ Elisa Kendall\inst{3} \ \ Adrian Paschke\inst{4} \ \ Davide Sottara\inst{5}}

\institute{
Athan Services (athant.com), West Lafayette, Indiana, USA\\
\email{taraathan@gmail.com}
\and
Raytheon, Fort Wayne, Indiana, USA\\
\email{Roy\_M\_Bell@raytheon.com}
\and
Thematix Partners LLC, New York, New York, USA
\email{ekendall@thematix.com}
\and
AG Corporate Semantic Web, Freie Universitaet Berlin, Germany\\
\email{paschke@inf.fu-berlin.de}
\and
Department of Biomedical Informatics, Arizona State University, USA\\
\email{davide.sottara@asu.edu}
}
%
\maketitle

\begin{abstract}
API4KP target the basic administration
services as well as the retrieval and the modification of expressions in machine-readable knowledge representation and reasoning (KRR) languages within heterogeneous (multi-language, multi-nature) knowledge platforms.
KRR languages of concern in this paper include but are not limited to RDF(S), OWL, RuleML and Common Logic, and the knowledge platforms may support one or several of these.
The presented API4KB ontologies provide a metamodel, or abstract syntax, for the communications between architectural elements, including a classification of knowledge source by mutability, structure, and an abstraction hierarchy as well as the use of performatives (assert, query, ...), languages, logics, dialects and formats. Finally, a framework is provided for defining operations on knowledge sources and platforms.
\end{abstract}

%
%\section{Introduction}
%\label{intro}
%TBD
% RDF graph, RDF source, RDF dataset
% http://www.w3.org/TR/2014/REC-rdf11-mt-20140225/

% OWL2 ontology version, ontology document, ontology series
\section{Introduction}
The inherent complexity of many application domains \-- including but not limited to finance, healthcare, law, telecom and enviromental protection \-- paired with the fast pace of innovation, requires increasingly robust, scalable and maintainable software solutions. Design patterns have shifted from monolithic applications towards distribution and service-orientation. Standards have been published to improve interoperability. Model driven architectures (MDA) have been adopted to support declarative, platform-independent specifications of an application's business logic \cite{Mellor:2004:MD:983969}. A special type of MDA, Knowledge Driven Architectures (KDA) \cite{Rector:2010}, rely on models such as ontologies that are not only standard, but also have a formal grounding in KRR. 
KDA, while not yet ubiquitous, have a variety of applications. Consider for example the following use cases:

\begin{enumerate}
\item % mixed stream and static sources in different languages
An internet RDF publisher of earthquake observations in a publish-subscribe architecture sends out a stream of RDF graphs over time. Each graph describes an observation, including the date, location and observed strength. The vocabulary used in the streamed RDF graphs is specified in RDFS, OWL or Common Logic (CL) ontologies specific to the units of measure, time, geospatial and geoscience domains. Users of this knowledge resource should be able to submit queries in SPARQL, receiving in response a stream of incremental query results, updated as new data becomes available.
\item % heterogeneous environment with data in a non-KRR language mapped to KRR language, plus multiple asynchronous sources
Devices in the Internet of Things (IoT) publish in compact sensor-specific data formats, such as XMPP (cite).  A ``connected patient'' system gathers input from a number of biomedical devices. A cognitive support application allows providers to query a patient's case using concepts defined in a modular medical ontology in OWL.
\item % side-effects
A reactive knowledge base contains event-condition-action (ECA) rules that describing actions that should be taken whenever events matching conditional patterns are detected. A smart home relies on ECA rules to adjusts the thermostat when the owner's car is within a given distance. Earlier in the day, it had placed an electronic order to the nearest supermarket.
\item % mutable
A legal knowledge source provides access to a legal code in the knowledge representation language LegalRuleML. Legal knowledge engineers add material to the system over time as laws are enacted or annulled, and occasionally correct errors in rendering. Queries to the system are processed based on the current snapshot of the legal code.
\item % fault-tolerant
Emergency response knowledge systems accept data and queries from mobile devices in the field where connectivity is unreliable. If a response to an information update or query request is not received within a reasonable time delay, the request is attempted again until it succeeds.
\end{enumerate}

%To allow for the greatest generality for these use cases, we will not assume that communications are local (in the virtual address space) or synchronous (although these properties could apply in some architectures), but support typical distributed architecture models by API4KB.  
From a systems-oriented perspective communicating entities in distributed systems are processes (or simple nodes in primitive environments without further abstractions) and from a programming perspective they are objects, components or services/agents. They may be single-sorted or many-sorted, with sorts being characterized by the kind of communications that may be initiated, forwarded or received, and by the kind of entity that may be received or forwarded from or sent to.
Communication channels may in general be many-to-many and uni- or -bidirectional. Each communication has a unique source; multi-source communications are not modelled directly, but are emulated by knowledge sources that publish streams that may be merged to give the appearance of multiple sources. We will allow for failure, either in communication or in execution, but do not specify any particular failure recovery strategy. 
Various types of communication paradigms are supported from strongly-coupled communication via low-level inter-process communication with ad-hoc network programming, loosely coupled remote invocation in a two-way exchange via interfaces  (RPC/RMI/Component/Agent) between communicating entities, to decoupled indirect communication, where sender and receiver are time and space uncoupled via an intermediary such as a publish-subscribe and event processing middleware.
The communication entities fulfill different roles and responsibilities (client, server, peer, agent) in typical architectural styles such as client-server, peer-to-peer and multi-agent systems. Their placement (mapping) on the physical distributed infrastructure allows many variations (partitioning, replication, caching and proxing, mobile) such as deployment on multiple servers and caches to increase performance and resilience, use of low cost computer resources with limited hardware resources or adding/removing mobile computers/devices.

Given this variety of architectural requirements, an abstraction is required to facilitate the interchange, deployment, revision and ultimately consumption of formal, declarative pieces of knowledge within a knowledge-driven application. We assembled a multi-disciplinary working group with the goal of creating a standard API for the interaction with the Knowledge Platform at the core of a KDA called API4KP. 

To provide a semantic foundation for the operations and their arguments, we have created a metamodel of knowledge sources and expressed it as an OWL ontology.
After providing some background notions in Section \ref{sec:bg}, we will describe the primary concepts in the metamodel in Section \ref{sec:metamodel}. In particular, a complete definition of the notion of (structured) knowledge resource will be provided in Section \ref{sec:structure}. 

\todo[inline]{Finally, use cases and related works....(complete after final use cases are written }


%\section{The API4KB and OntoIOp RFPs}
%\label{sec:bg}
%\subsection{The API4KB RFP + DOL}

%In the early to mid-2000s, a number of Object Management Group (OMG) members developed applications that explored various aspects of semantic technologies.  As practitioners of Model Driven Architecture (MDA) methods \cite{Mellor:2004:MD:983969} and information architecture (IA), they recognized limitations in the ability to modularize and reuse aspects of semantic technology in the applications they were constructing.  IA in this context is focused on defining, developing, and managing information, and in particular information models, in order to separate content and context-specific concerns from other aspects of the software, process, or service architecture of a system or business.  They teamed to develop an OMG Request for Proposal (RFP) \cite{API4KB}, that asked for: 
%\begin{itemize}
%\item  a set of standard interfaces to knowledge bases, described in OWL and RDF Schema, that might extend to other description logic languages, RDF, and other knowledge representation languages
%\item access to, and modification of, knowledge base content and the ontologies (schema) that support them
%\item access to relevant features of the knowledge management systems themselves, including, but not limited to parsing, querying, reasoning, and other capabilities.
%\end{itemize}
%
%Work on the original RFP was postponed for a variety of reasons, including resource constraints, availability of expert architects who understood the importance of and requirements for true interoperability among knowledge-based services, and enabling infrastructure that would allow rule-based systems and description logic-based systems to be used together consistently.
%
%The missing infrastructure, which started as an ISO specification and ultimately moved to the OMG, was provided in part through the OntoIOp (Ontology, Model And Specification Integration And Interoperability) RFP \cite{OntoIOp} and resulting DOL (The Distributed Ontology, Model, and Specification Language) language. The OntoIOp RFP asked for:
%\begin {itemize}
%\item A specification for an abstract metalanguage with an associated metamodel targeted at cross-language interoperability among a class of concrete languages used to record logical expressions found in ontologies, models and specifications.
%\item A list of concrete languages and translations to be recognized and correctly processed by implementations of this specification. 
%\item A description of constraints and conformance criteria for additional concrete languages and translations between concrete languages that are not explicitly supported, but nonetheless have equivalent uses that could be recognized and correctly processed by implementations.
%\end{itemize}
%
%By early 2014, the DOL and API4KP submission teams began working together to provide a language and set of related interfaces to solve the problems identified by both groups independently. An initial submission for DOL \cite{DOL} was presented to the OMG in November 2014, and is currently under revision, with a planned submission for adoption in June 2014.  The API4KPs initial submission, which leverages the DOL effort, will be submitted initially in September 2015, with a planned revision for adoption in early 2016. The work described in this paper summarizes some of the findings of the API4KPs team.

%Example 4 Query results may reflect the structure of the structured knowledge asset to which they are applied. For example, a query applied to a Try of a derived knowledge asset may return a Failure if an exception arises in the derivation of the knowledge asset.

%Combining examples 1-4, streaming data from sensors is provided with semantics by the language environment, combined with ECA rulebases and failure management based on a Try structure for a reliable reactive semantic CEP system.
% ****************


\section{API4KP Metamodel}
\label{sec:metamodel}
The API4KP metamodel is hierarchical, with a few under-specified concepts at the upper levels, and more precisely defined concepts as subclasses.
\subsection{Upper Levels of the Metamodel}
\label{sec:upper}
The principle upper-level concepts in the API4KP metamodel are
\begin{description}
%\item[Communicating Entity] architectural elements that may communicate (initiate, forward or receive communications) with other elements.
\item[Knowledge Source:] source of machine-readable information with semantics. Examples: an RDF graph, a mutable RDF source, an RDF dataset with specified semantics, or a relational database with a mapping to an ontology.
\item[Environment:] mathematical structure of mappings and members, where the domain and codomains of the mappings are members of the environment.  Example: a KRR language environment containing semantics-preserving translations from RDF and OWL into Common Logic.
\item[Knowledge Operation:] function (possibly with side-effects. i.e. effects beyond the output value returned) having a knowledge source, environment or operation type in its signature. Examples: creating, modifying, deleting, parsing, translating, querying, downloading, or reasoning about a knowledge source.
\item[Knowledge Event:] successful evaluation or execution of a knowledge operation by a particular application at a particular time.
\end{description}
These definitions are intentionally vague so as to be adaptable to a variety of implementation paradigms.

%\subsection{Architecture}
%To allow for the greatest generality, we will not assume that communications are local (in the virtual address space) or synchronous - although these properties could apply in some architectures.
%Communication channels may in general be many-to-many and uni- or -bidirectional, but a particular communication will have a unique sender. (cite low-level 0MQ and high-level RuleResponder SEDA Architecture http://responder.ruleml.org supporting e.g. JMS, ActiveMQ, and RabbitMQ)
%Each communication has a unique source; multi-source communications are not modelled directly, but are emulated by knowledge sources that are accessed as streams. We will allow for failure, either in communication or in execution, but do not specify any particular failure recovery strategy. Communicating entities may be single-sorted or many-sorted, with sorts being characterized by the kind of communications that may be initiated, forwarded or received, and by the kind of entity they may be received or forwarded from or sent to.
%
%The API4KP architectural elements are categorized according to the following competency questions in the ontology.
%
%\begin{enumerate}
%\item What are the entities that are communicating in the %distributed API4KP system?
%\item How do they communicate, or, more specifically, what communication paradigm is used between API4KP entities?
%\item What (potentially changing) roles and responsibilities do they have in the overall API4KP architecture?
%\item What is the mapping of the API4KP elements into a physical distributed infrastructure?
%\end{enumerate}
%
%\textbf{Communicating Entities}
%
%\begin{description}
%    \item [Node:] In primitive environments such as sensor networks, operating systems does not provide any abstractions, therefore (hardware) nodes communicate.
%    \item [Process:] In most environments processes are supplemented by threads, so threads are more the endpoints of communications.
%    \item [Object:] Computation is encapsulated by a number of interacting distributed objects representing units of decomposition for the problem domain. Objects are accessed via interfaces.
%    \item [Component:] Resemble objects in that they offer problem-oriented abstractions, also accessed via interfaces. They specify not only their interfaces but also the assumptions they make in terms of other components/interfaces that must be present for a component to fulfill its function.
%    \item [Service] and [Agent:] Software application which is identified via URI and can interact with other software agents (typically using a higher-level coordination and negotiation protocol).
%\end{description}
%
%\textbf{Communication Paradigms}
%
%\begin{description}
%    \item [Strongly Coupled Communication:] Low-level, direct API access requiring direct knowledge of the (downloaded) API4KP [Artifacts] or inter-process communication in distributed systems with ad-hoc network programming including message parsing-primitives.
%    \item [Loosely Coupled Communication:] Loosely coupled remote invocation in a two-way exchange via an [Interface] (RPC/RMI/Component/Agent) between communicating entities.
%    \item [Decoupled Communication:] Indirect communication, where sender and receiver are time and space uncoupled via an [Intermediary].
%\end{description}
%
%\textbf{Roles}
%
%For instance, client-server, peer-to-peer, agent architecture styles.
%
%\begin{description}
%    \item [Client:] Client knows server (after discovery) and requests a particular knowledge resource service
%    \item [Server:] Server is the central entity and provider of services and knowledge resources
%    \item [Peer:] Peer is client/requester and provider ([Servant]) at the same time. Knowledge resources are shared between peers and can be accessed from other peers.
%    \item [Agent:] an abstraction from the client-server or peer-to-peer architecture style into [orchestrated] or [choreography style] agent architectures.
%\end{description}
%
%\textbf{Placement}
%
%\begin{description}
%    \item [Partitioning:] API4KP services provided by multiple servers by partitioning a set of objects in which the service is based and distribute them between multiple-services.
%    \item [Replication:] Server maintain replicated API4KP server copies of them on several hosts (horizontal replication) or distributed API4KP functions into distributed peers.
%    \item [Caching] and [Proxying:] A [Cache] stores recently used knowledge resources. Caches might be co-located with each client or located in a Proxy. [Proxy] provides a surrogate or placeholder for a API4KP knowledge object to control access to it.
%    \item [Mobile:] Mobile (executable) code that is downloaded to a client or mobile components/agents, which are running programs (both code and data/resources + state) that travel from one computer / environment to another.
%\end{description}

\subsection{Knowledge Source Hierarchy}
We have developed a hierarchy of \emph{knowledge source level} of abstraction that is a generalization of the FRBR \cite{FRBR} Work-Expression-Manifestation-Item (WEMI) hierarchy of abstraction tailored for machine-readable KRR languages. The fundamental building blocks of knowledge sources are \emph{basic knowledge resources}, which are immutable knowledge sources without structure.
Subclasses of basic knowledge resources are defined according to their knowledge source level. 
\begin{description}
\item[Basic Knowledge Expression:] well-formed formula in the abstract syntax of a machine-readable language.\footnote{The use of "basic" in API4KP differs from its usage in DOL - a DOL basic OMS is a set, and corresponds to a Set-structured knowledge asset in API4KP.}
Example KE1: the instance of the OWL 2 DL abstract syntax for an ontology version from an ontology series KA1, differing from other versions of the series only in the natural language definitions.
\item[Basic Knowledge Manifestation:] character-based embodiment of a basic knowledge expression in a concrete dialect. Example KM1: the OWL/RDF XML abstract DOM instance of example KE1.
\item[Basic Knowledge Item:] single exemplar of a basic knowledge manifestation in a particular location. Example KI1: a file on a network server embodying example KM1.
\item[Basic Knowledge Asset:] equivalence class of basic expressions determined by the equivalence relation of an asset environment (see Section~\ref{krassetenv}.) Example KA1: an OWL2 DL ontology series, viewed as an equivalence class of basic knowledge expressions in OWL2 DL, including example KE1, according to a semantics-preserving environment for the OWL2 DL language where the mapping to the focus language strips the natural language definitions from the axioms.
\end{description}

API4KP lifting/lowering operations (see \ref{sec:op}) provide transformations from one level to another complying with the following relations:
\begin{description}
\item[exemplify:] to instantiate (a knowledge manifestation) in particular format(s) and at particular location(s) (address in some virtual address space). Example: KI1 exemplifies KM1, KM1 prototypes KI1.

Inverse: \emph{prototype}
\item[embody:] to represent (a knowledge expression) in concrete syntax(es) (dialects) of particular KRR language(s). Example: KM1 embodies KE1, KE1 parses KM1.

Inverse: \emph{parse}
\item[express:] to represent (a knowledge asset) in abstract syntax(es) of particular KRR language(s). Example: KE1 expresses KA1, KA1 conceptualizes KE1.

Inverse: \emph{conceptualize}
\end{description}
Note that plurality in the above definitions corresponds to heterogeneous knowledge sources, not non-determinism.

\subsection{Mutability}
Following RDF concepts\cite{RDF2014}, knowledge sources are characterized as mutable or immutable, and immutable knowledge sources are called \emph{knowledge resources}. In this context, immutable does not necessarily mean static;  a stream of knowledge, e.g. a feed from a sensor, may be considered an \emph{observable} knowledge resource that is revealed over time, as described further in Section~\ref{sec:structure}.
A \emph{mutable knowledge source} is a container that has, at any point in time, an explicit state that is fully represented by a knowledge resource. The language, structure and content of a mutable knowledge source may change over time; however, the abstraction level is unchanging.

We distinguish between the \textit{implicit} state that a mutable knowledge source holds indirectly when operators such as actions, complex  event patterns or aggregations are computed on it, and the explicit state that evolves with time and that can be managed explicitly by an additional state transformer component responsible for \textit{explicit} state management, concurrency control, reasoning (specifically, inference of state deltas), and state updates. 
There are various ways to manage explicit state, e.g. embedded inside the processors of the knowledge source in global variables or state accumulating variables or tuples that are available either locally to an individual operator or across the operators as a shared storage, or with explicit state and concurrency control which lies outside of knowledge resource processors, e.g. by threading the variables holding state through a functional state transformer and by using State monads (see \ref{sec:structure}), which exist within the context of another computation or transformation, thus allowing to attach state information to any kind of functional expression.


%A composable environment contains the mappings that are the composition of all compatible pairs of its mappings. An associative environment satisfies an associative property on composition of its mappings. A categorical environment is an associative environment that includes an identity mapping for every member.
\subsection{Environments}
In DOL, a concept of heterogeneous logical environment is defined as 
"environment for the
expression of homogeneous and heterogeneous OMS, comprising
a logic graph, an OMS language graph and a supports relation".
In API4KP, we generalize this concept of environment as follows.
\label{krassetenv}
\begin{description}
%\item[Composable Environment:] environment that contains the mappings that are the composition of all compatible pairs of its mappings
%\item[Associative Environment:] composable environment that satisfies an associative property on composition of its mappings
\item[Categorical Environment:] environment with an associative composition operation for mappings, that is closed under composition and contains an identity mapping for every member
\item[Language Environment:] environment whose members are languages
\item[Focused Environment:] nonempty environment which has a member F (called the focus or focus member) such that for every other member A, there is a mapping in the environment from A to F
\item[Preserving Environment:] environment where every mapping preserves a specified property
\item[Asset Environment:] focused, categorical, preserving language environment where the focus is a KRR language
\end{description}
The special case where all languages in an asset environment are KRR languages supporting model-theoretic semantics without side-effects (logics), and the preserving property is characterized by a logical graph reduces to a heterogeneous logical environment as defined in DOL.

\subsection{Performatives}
The Knowledge Query and Manipulation Language\cite{Finin:1994:KAC:191246.191322} introduced the concept of \emph{performatives}, which was later extended by FIPA-ACL\cite{FIPA-ACL}.
The KRR Languages covered by API4KP include ontology languages (e.g. OWL), query languages (e.g. SPARQL), languages that describe the results of queries, events and actions (e.g KR RuleML), and declarative executable languages (e.g. Prolog, ECA RuleML). In the latter case, the languages typically includes syntactic constructs for performatives, e.g. \emph{inform}, \emph{query}, and the description of a knowledge resource may include a list of the performatives that are used within it.  Performatives will be modelled as \emph{operations} as defined in Section~\ref{sec:op}.

% Assert- 

%Knowledge resources expressed in ontology languages may be considered as informative, e.g. when received from an untrusted source, or as providing an \emph{assert}. Query resources may also be considered informative, e.g. when the sender is unauthorized, or as providing a \emph{query} performative. Some languages (e.g. RuleML) have syntactic structures for assert, retract and query performatives, and are extensible to other actions.


\subsection{Descriptions}
As stated above, we do not make assumptions regarding the drivers for communications, e.g. an implementation may be message-driven, event-driven, or a combination of both. However, our metamodel takes a message-centric perspective, with the message body typically being a description of a knowledge source or a knowledge operation.

A \emph{knowledge source description} is a knowledge resource whose subject matter is another knowledge source, which may be expressed, e.g., as an OWL ontology of individuals or an RDF graph. The properties and classes in the API4KP namespace that may be employed in knowledge source descriptions are listed in the following tables and formalized in the API4KP OWL ontologies. Further, IRIs in other namespaces may be used to express metadata within a knowledge source description. A description about the description itself may be referenced through an IRI, or included within the description explicitly through the :hasDescription property,  OWL annotations, or as an RDF dataset\cite{RDF2014b}.

%some tables
\begin{table}[h]
\begin{minipage}[b]{0.20\linewidth}
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Key} & \textbf{Value} \\ \hline
Y            & exactly 1      \\ \hline
Y+           & 1 or more      \\ \hline
Y?           & 0 or 1         \\ \hline
Y*           & 0 or more      \\ \hline
N            & exactly 0      \\ \hline
I[+?*]       & indirect      \\ \hline
\end{tabular}
\caption{Legend}
\label{legend}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.70\linewidth}
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Prefix} & \textbf{Expansion} \\ \hline
:            & \url{http://www.omg.org/spec/API4KP/API4KPTerminology/}      \\ \hline
ks:            & :KnowledgeSource/      \\ \hline
kr:            & :KnowledgeResource/      \\ \hline
ka:            & kr:Asset/      \\ \hline
ke:            & kr:Expression/      \\ \hline
km:            & kr:Manifestation/      \\ \hline
ki:            & kr:Item/      \\ \hline
lang:            & :Language/      \\ \hline
map:            & :Mapping/      \\ \hline
xsd:            & \url{http://www.w3.org/2001/XMLSchema#}     \\ \hline
\end{tabular}
\caption{Prefix Mappings}
\label{abbreviations}
\end{minipage}
\end{table}
 
\begin{table}[h]
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
\textbf{Property}  & \textbf{Range}
& \textbf{ka:}
& \textbf{ke:}
& \textbf{km:}
& \textbf{ki:}
\\ \hline
:hasIdentifier      & :Identifier        & Y?                & Y?                     & Y?             & Y?               \\ \hline
:level              & ks:Level           & Y                 & Y                      & Y              & Y                \\ \hline
:usesPerformative   & :Operation      & I*                & Y*                     & I*              & I*                \\ \hline
:hasLocator         & :Address           & Y?                & Y?                     & Y?             & Y                \\ \hline
:usesLanguage       & :Language       & I*                & Y*                     & I*             & I*               \\ \hline
:usesDialect        & km:Dialect        & N                 & N                      & Y*             & I*               \\ \hline
:usesConfiguration  & ki:Configuration   & N                 & N                      & N            & Y*               \\ \hline
:accordingTo        & lang:Environment     & Y                 & N                      & N              & N                \\ \hline
:isBasic            & xsd:boolean        & Y                 & Y                      & Y              & Y                \\ \hline
:isOutputOf         & ev:               & Y?                    & Y?                   & Y?    & Y?       \\ \hline
:hasMetaData        & :KnowledgeResource & Y*                & Y*                     & Y*             & Y*               \\ \hline
:hasDescription   & :KnowledgeResource       & Y*                & Y*                     & Y*             & Y*   \\ \hline
\end{tabular}
\caption{Knowledge Resource Metamodel}
\label{kronto}
\end{table}

\begin{table}[h]
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
\textbf{Property}  &\textbf{Domain}  & \textbf{Range}  & \textbf{Inverse}
\\ \hline
:exemplify (?)   & ki:        & km:     & :prototype (*)         \\ \hline
:embody (?)      & km:        & ke:     & :parse (*)             \\ \hline
:express (*)     & ke:        & ka:     & :conceptualize (*)     \\ \hline
\end{tabular}
\caption{Knowledge Resource Elevation Properties}
\label{krelevationprop}
\end{table}

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|l|l|l|}
 \hline
\textbf{Property} & \textbf{Range} & \textbf{ke:Language} & \textbf{km:Dialect}  & \textbf{ki:Configuration} \\ \hline
:hasIdentifier    & :Identifer     & Y                    & Y                   & Y                       \\ \hline
:hasLocator       & :Address       & N                    & N                   & Y?                        \\ \hline
:supports         & :Logic         & Y                    & I                   & I                         \\ \hline
:usesLanguage     & ke:Language    & N                    & Y                   & I                         \\ \hline
:usesDialect      & km:Dialect     & N                    & N                   & Y                         \\ \hline
:usesFormat       & ki:Format     & N                    & N                   & Y                         \\ \hline
:location         & :Address       & N                    & N                   & Y       \\ \hline
\end{tabular}
\caption{Knowledge Resource Configuration Metamodel}
\label{krlang}
\end{table}

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|l|l|l|}
 \hline
\textbf{Property} & \textbf{Range} & \textbf{T:Environment}    \\ \hline
:hasIdentifier    & :Identifer      &  Y?                       \\ \hline
:mapping          & T:Mapping       &  Y*                       \\ \hline
:focus            & T:              &  Y?                       \\ \hline
:preserves        & T:EquivalenceRelation    &  Y*              \\ \hline
:isOutputOf       & ev:             &  Y?              \\ \hline
\end{tabular}
\caption{Generic Environment Metamodel. The generic prefix T: specifies the member type. Specific environments include lang:Environment (a system of mappings between the abstract syntax of languages), qlang:Environment (a system of mappings between query languages)}
\label{krenvonto}
\end{table}

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|l|l|l|}
 \hline
\textbf{Property} & \textbf{Range} & \textbf{T:Mapping}   \\ \hline
:hasIdentifier    & :Identifer     &  Y?                       \\ \hline
:location         & :Address       &  Y?                       \\ \hline
:start          & T:               &  Y                       \\ \hline
:end            & T:               &  Y                       \\ \hline
:preserves        & :EquivalenceRelation    &  Y*              \\ \hline
:usesLanguage     & map:Language    &  Y*              \\ \hline
:isBasic         & xsd:boolean     &  Y              \\ \hline
:components      & T:MappingList     &  Y?              \\ \hline
\end{tabular}
\caption{Generic Mapping Metamodel}
\label{krmaponto}
\end{table}


\subsection{Operations and Events}
\label{sec:op}

In the API4KP framework, the building blocks for all knowledge operations are \emph{actions} -- unary functions, possibly with side-effects and possibly of higher-order. Actions are defined in terms of their possible events. To maintain a separation of concerns, side-effectful actions are assumed to be void, with no significant return value. Particular kinds of actions include:

\begin{description}
      \item[Lifting Action:] side-effect-free action whose output is at a higher knowledge source level than the input
      \item[Lowering Action:]  side-effect-free action whose output is at a lower knowledge source level than the input
      \item[Horizontal Action:] side-effect-free action whose output is at the same knowledge source level as the input
      \item[Idempotent Action:] side-effect free action that is equal to its composition with itself (A = A o A)
      \item[Higher-Order Action:] side-effect-free action whose input or output (or both) is an action
\end{description}
Lifting and lowering are utility actions for changing the knowledge source level, e.g. parsing and IO. 
Horizontal actions are useful e.g. for constructing structured knowledge sources, while higher-order actions are needed to specify more complex operations e.g. querying.

In this framework, we define two void actions that have side-effects on the state of mutable knowledge resources:
  \begin{description}
    \item[Put:] void action whose input is a mutable knowledge source and has the side-effect of setting the mutable knowledge source to a particular, fully-specified state
    \item[Update:] void action whose input is a mutable knowledge source and has the side-effect of setting the mutable knowledge to a new state that is the result of applying a side-effect-free action to the current state
  \end{description}
  
  A side-effectful operation can be considered idempotent if its successful execution multiple times (synchronously) leads to no additional detectable side-effects beyond that of the first execution. Note that this is a different, but related, concept of idempotence than that for side-effect-free actions. An Update action based on an idempotent side-effect-free action is idempotent in this sense. A Put action is always idempotent.

\begin{table}[h]
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
\textbf{Property}  &\textbf{Domain}  & \textbf{Range}  & \textbf{Inverse}
\\ \hline
:hasEvent (*)      & op:               & ev:             & :isEventOf  (1)         \\ \hline
:executes (*)      & :Application      & ev:             & :isExecutedBy  (1)         \\ \hline
:input (?)         & ev:ActionEvent    &    :          & :isInputOf  (*)         \\ \hline
:output (?)        & ev:               &    :          & :isOutputOf  (?)         \\ \hline
:atTime (1)        & ev:               &    xsd:dateTime          &          \\ \hline
\end{tabular}
\caption{Knowledge Resource Operation and Event Properties}
\label{kropprop}
\end{table}

\section{Structured Knowledge Resources}
\label{sec:structure}
We generalize the DOL concept for structured OMS (ontologies, models and specifications) to define a concept of structured knowledge resource for each level of abstraction. In DOL, a structured OMS "results from other basic and structured OMS by import, union, combination, ... or other structuring operations".
In API4KP, A \emph{structured knowledge resource} is a collection whose components are knowledge resources of the same level of abstraction, and knowledge operations will be provided to construct structured knowledge resources from other knowledge sources (see Sec/~\ref{sec:op}).
\begin{description}
\item[Structured Knowledge Expression:] collection of knowledge expressions (either structured or basic), which are not necessarily in the same language and may themselves have structure. ExampleKE2: a heterogeneous set of RDF graphs, OWL, Common Logic expressions and data in a relational model. Example KE3: the OWL 2 DL ontology series KA1, viewed as a collection of expressions rather than an equivalence class.
\item[Structured Knowledge Manifestation:] collection of knowledge manifestations (either structured or basic), which are not necessarily in the same language or dialect and may themselves have structure. Example KM2: a heterogeneous structure of RDF Turtle, OWL Manchester and SQL as sequences of string tokens, and OWL/XML, RuleML and Common Logic XCL2 as XML abstract DOM documents embodying example KE2.
\item[Structured Knowledge Item:] collection of knowledge items  (either structured or basic), which are not necessarily in the same language, dialect, format or location, and may themselves have structure. Example KI2:  a heterogeneous structure of an RDF triple store, an RDF/XML sensor feed, a MySQL database , RuleML XML files on a local hard drive and Common Logic XCL2 files on a network server in a content management system, exemplifying example KM2.
\item[Structured Knowledge Asset:] collection of knowledge assets  (either structured or basic), which are not necessarily according to the same environment, but where there is a unique language that is the focus of the environment of each component. Example KA2: a heterogeneous structure of assets conceptualized from the RDF, OWL and Common Logic expressions of example KE2 according to an environment that provides translations from RDF or OWL into Common Logic, and an ontology-based data access (OBDA) source schema providing a mapping from the relational model to OWL.
\end{description}


To assist in defining operations on structured knowledge sources while still maintaining generality, the collection structure of a structured knowledge resource is required to arise from a monad functor. Collection structures that satisfy these requirement include sets, bags and sequences, but other useful structures also meet these requirements.

\subsection{Monads}
In seminal work that established a theoretical foundation for proving the equivalence of programs, Moggi\cite{moggi_notions_1991} applied the notion of monad from category theory\cite{MacLane1998} to computation.
As defined in category theory, a monad  is an endofunctor on a category C (a kind of mapping from C into itself) which additionally satisfies some requirements (the monad laws).
In functional programming, monads on a particular category are of interest - the category with types as objects and programs as arrows.
For example, the List[\_] typeclass is a monad, e.g. List[Int] is a type that is a member of List[\_].

Each monad has the following transformations (exemplified for the List monad where lists are denoted with angle brackets)
\begin{itemize}
\item unit: A $\Rightarrow$ M[A] lifts the input into the monad (e.g. unit(2) = $\langle$2$\rangle$)
\item join: M[M[A]] $\Rightarrow$ M[A] collapses nested monad instances by one level (e.g. join($\langle$$\langle$1, 2$\rangle$, $\langle$3, 4$\rangle$$\rangle$) = $\langle$1, 2, 3, 4$\rangle$)
\item map: (A $\Rightarrow$ B) $\Rightarrow$ (M[A] $\Rightarrow$ M[B]) takes a function between two generic types and returns a function relating the corresponding monadic types (e.g. map( s $\Rightarrow$ 2*s)($\langle$1, 2$\rangle$) = $\langle$2, 4$\rangle$)
\end{itemize}
Note that we choose the unit, join and map transformations\cite{Wadler1992} as fundamental in this development of the monad laws because it is useful for later discussion on tree structures, whereas the usual theoretical treatment, based on unit and bind = join o map, is more concise.

The map transformation defines a functor M, satisfying the functor laws:
\begin{description}
\item[Functor Identity] map(id)(y) = y
\item[Functor Associativity] map(f o g) = map(f) o map(g)
\end{description}
where id is identity function s $\Rightarrow$ s.
The unit and join transformations arise from natural transformations related to M, satisfying:
\begin{description}
\item[Unit from Natural Transformation] map(f)(unit(x)) = unit(f(x))
\item[Join from Natural Transformation] join(map(join)(x)) = join(join(x))
\end{description}

Further, these transformations must obey the monad laws:
\begin{description}
\item[Monad Left Identity] join(map(unit)(x)) = x
\item[Monad Right Identity] join(unit(x)) = x
\item[Monad Associativity] join(map(map(f))(x)) = map(f)(join(x))
\end{description}

Monads of relevance to API4KP include
\begin{description}
\item [Option:] handles nullability, has subclasses Some, which wraps a knowledge resource, and None, which is empty
\item [Try:] handles exceptions, has subclasses Success, which wraps a knowledge resource, and Failure, which wraps a (non-fatal) exception
\item [Future:] handles concurrency, describes a process whose output may become available at some time
\item [IO:] handles IO side-effects, wraps a knowledge resource and an \emph{item configuration}
\item [Task:] handles general side-effects, wraps a knowledge resource and a description of a side-effectful task
\item [Observable:] handles streams, wraps a sequence of knowledge resources that become available over time
\item [Key-Value Map:] handles labelled structure, a knowledge resource is associated with each key in some set
\item [Heterogeneous List:] handles a specified pattern of knowledge resource subclasses (e.g. RuleML rulebase together with an OWL ontology defining the sort hierarchy, CL text with sidecar RDF metadata).
\item [State:] handles state, wraps a knowledge resource (the state) and implements state transitions
\end{description}
These monad functors may be composed; for example, given a basic knowledge expression type E, the type (State o Try o List) [E] = State[Try[List[E]]] may be defined.
%be of type State of type Try of type List of type basic knowledge expression.
In general, the composition of monads is not necessarily a monad. 
%For example, (Set o List)[\_] is a typeclass, with members of type Set[List[A]], i.e. sets of lists of type A.



\subsection{Monadic Tree Structures}
The monad structures needed for API4KP are a restricted form of the monads seen in functional programming - rather than applying to category of all types, these monads are functors on a smaller category of knowledge resource types. In DOL, the concept of structured expression using sets is introduced. For example, let B be the category of (basic) Common Logic text expressions, and Q[B] = B or Set[Q[B]], where Set[Q[B]] is the typeclass of SetTree-structured Common Logic expressions. In particular, a member of type SetTree[B] is specified by a Set whose members are either  basic leaves (of type B) or structured branches (of type Set[Q[B]]). 

The Set monad is appropriate for defining structured expressions in monotonic logics, like Common Logic, because the order and multiplicity of expressions in a collection has no effect on semantics. The semantics of CL is provided by the CL interpretation structure that assigns a truth-value to each basic CL text expression. The truth-value of a set of CL text expressions is true in an interpretation I if each member of the set maps to true in I. The truth value I(y) of a SetTree-structured CL expression y is defined to be I(flatten(y)), where flatten(y) is the set of leaves of y.

We generalize this approach for defining the semantics of structured expressions to an arbitrary language L with basic expressions E and M-tree structured expressions. We assume that 
\begin{itemize}
\item M is a monad on the category of types,
\item model-theoretic semantics is supplied through an interpretation structure I defined for basic expressions in E and simply-structured expressions M[E],
\item a post-condition contract for side-effects is specified by a truth-valued function P(F, y) for all supported void knowledge actions F and all y in E or M[E].
\end{itemize}

Let N[\_] be the M-tree monad corresponding to the minimal (finite) fixed point of N[E] = M[E or M[N[E]]], where "A or B" is used as an abbreviation for an unbiased Either[A, B] bifunctor.
The unit function for N is the same as the unit function for M.
The map and join functions for N are defined from a straight-forward recursive application of the map and join functions for M.
The satisfaction of the monad laws is dependent on the use of the Either bifunctor to handle the union types, so that the left or right intention is preserved even in the case when the types are not disjoint. In particular,
$$join_N = (join_M o map_M)( bimapOne( id) (unit_M o unit_R o join_N) ) $$
$$ map_N(f) = map_M( bimap(f, map_N(f)) ) $$
 where casting between M and N is implicit and the following functions for the Either bifunctor are used:
 $$bimapOne: (A=>C) => (B=>C) => ((A \mathop{\mathrm{or}} B)=> C)$$
 $$  bimap   : (A=>C) => (B=>D) => ((A \mathop{\mathrm{or}} B)=> (C \mathop{\mathrm{or}} D))$$
 and $unit_R$ is the right-biased monadic type constructor for Either.

If E is a type of basic knowledge resources, then N[E] is the type of M-tree-structured knowledge resources, and
Q[E] = E or N[E] is the corresponding type of knowledge resources (either basic or structured). By convention, the M-tree monad is named by appending "Tree" to the name of the underlying monad; thus, SetTree[E] = Set[E or Set[SetTree[E]]].

For all x, y $\in$ Q[E], define
\begin{description}
\item[level:] Q[E] $\Rightarrow$ N[E]
%= bimapL(unit, id)
such that level(x) = unit(x), if x $\in$ E, x otherwise
\item[flatten:] Q[E] $\Rightarrow$ M[E]  
such that flatten(y) = y if y $\in$  E or M[E], flatten( join$_N$(map$_M$(level)(y)) otherwise
%= bimap(id, flatten_N)
%\item[flatten_N:] N[E] $\Rightarrow$ M[E]  = bimap(id, flatten_N)
\end{description}
%where bimapL is a left-biased 
Then for all y $\in$ Q[E], we may define the interpretation I(y) = I(flatten(y)), with entailments defined accordingly. %Similarly the pragmatics (side-effects) are specified by P(flatten(y)).
Implementations that honor the semantics must satisfy P(F, y) = P(F, flatten(y)), where P is a function representing the post-conditions after execution of side-effectful knowledge operation F on the knowledge resource y.

% composition of monads is a functor (not necessarily a monad)
Like other monads, M-tree monads can be combined through composition.
For example, a system of multiple concurrent threads may be modelled as a Set-structure of Stream-structured knowledge resources: SetTree o StreamTree.
%   StreamTree[A] = Stream[A or Stream[StreamTree[A]]]


\subsection{Heterogeneous Structures}
% monad tree in two langauges, with focus A and leaf B
Suppose A and B are expression types of two languages where an environment provides a semantics-preserving transformation T from B to A.
Further suppose that an interpretation mapping I is defined on A or M[A].
The Either type E = A or B defines the basic knowledge expressions in this environment, while structured expressions are N[E] where N is the M-tree monad  N[E].
The Either type Q[E] = E or N[E] contains all expressions in this environment, basic or structured. 

Using the transformation T from the environment, we may define the interpretation of the M-tree structured expressions in terms of the interpretations of basic expressions in A and operations on monads. In particular,
\begin{itemize}
\item S(x) = T(x) if x $\in$ B, x otherwise
\item I(x) = I( map(S)(flatten(x)) )
\end{itemize}
Notice that the expressions of type B are not required to be in a knowledge representation language. They could be in a domain-specific data model based on XML, JSON or SQL. The semantics of expressions of type B are derived from the transformation to type A, the focus  knowledge representation language of the environment. API4KP employs this feature to model ontology-based data access (OBDA) and rule-based data access (RBDA).

Structured expressions can always be constructed in a monad that has more structure than necessary for compatibility with the semantics of a given language.
For example, List and Stream monads can be used for monotonic, effect-free languages even though the Set monad has sufficient structure for these languages;
a forgetful functor is used to define the semantics in the monad with greater structure in terms of the monad of lesser structure.
A heterogeneous structure of languages containing some languages with effects and others without effects (e.g. an ECA rulebase supported by ontologies) could thus make primary use of an M-tree monad that preserves order, such as ListTree or StreamTree, while permitting some members of the collection to have a SetTree structure. 
%In particular, if A is an ECA rulebase language and B is an ontology language, then ListTree[ A or SetTree[B]] would be an appropriate monadic tree structure for heterogeneous knowledge expressions in these two languages. 
%In general, a right-biased disjunction (REither) of monads instances of the same generic type can serve as a basis for tree structures as follows: 
% M[E] = REither[M1[E], M2[E]] is a monad provided:
%    unit_M(x) = Right( unit_M2(x))
%    map_M(x)  = map_M1(x) if x is Left, map_M2(x) if x is Right
%    join_M(x) = join_M2(x) if x is Right[Right],
%                otherwise, the value is obtained by lifting x into Right[Right] by 
% applying a (full) lifting functor G:M1 => M2 that is a right adjoint of a 
% (restricted) forgetful functor F: M2 => M1
% Purpose: For use with two languages, A and B where M2 is a monad that is compatible with A and B, while
% M1 is a monad compatible only with A.
% N1[A] = M1[Q1[A]]
% Q1[A] = Either[A, N1[A]]
% E = Either[Q1[A], B]
% Let N2[E] = M2[Q2[E]]
% Q2[E] = Either[E, N2[E]] 
% R[A, B] = Q2[Either[Q1[A], B]]



\subsection{Structure of Mutable Knowledge Sources}
While an immutable knowledge source (i.e. a knowledge resource) has a specific structure, as discussed above, a mutable knowledge source has structure only indirectly through the structure of its state. In general, the structure of a mutable knowledge source's state changes arbitrarily over time, but could be restricted in order to emulate common dynamic patterns. Simple examples include state as a basic knowledge resource (linear history without caching), a key-value map with values that are basic knowledge resources (branching history without caching), or a sequence of basic knowledge resources (linear cached history). 


% The connection between mutable knowledge resources and the State monad needs further exploration
%The State monad provides a convenient structure where the specification of state transitions is encapsulated together with the current value of the state.

\section{Proof-of-Concept}

%\subsection{Application of Monadic Tree Structures to Use Cases}

\begin{enumerate}
\item The RDF stream of earthquake observations can be modelled using a Stream monad (also called Observable).
A query registered against this RDF Stream will generate another Stream, with each item containing additions (if any) to the query result due to the assertion of the newly-arrived graph.
Because RDF has monotonic semantics, the accumulated query results will always be equivalent to the result of the query applied to the accumulated graphs of the stream.
Transformations that operate cumulatively, as this notion of query does, on a collection (e.g. set, list, stream, tree) are typically called "fold" or "traverse". (The "reduce" of map-reduce is a particular kind of fold.)
Therefore, cumulative queries and other cumulative operations on Streams may be implemented through folding.

If it is known that a query update will be independent of portions of the stream older than some fixed time interval, then
the fold may incorporate windowing of the stream (e.g. deleting graphs older than some duration from cache) to optimize the computation without affecting entailments.

\item The connected-patient system uses a heterogeneous language environment to map the input XMPP data into a KRR language, employing terms from a vocabulary defined in a common ontology. The structure of this system may be modelled as a Set of Streams, since each device streams its output asynchronously.

\item State, Task and IO monads are appropriate to the use case of an active knowledge base where evaluation of an operation leads to side-effects; the choice of monad depends on the nature of the side-effects and the implementation.
Equivalence of such knowledge resources requires not only the same entailments, but also side-effects that are in some sense equivalent.
The smart home system may be modelled using a State monad, where changes to the state of the thermostat is a side-effect.

\item The legal knowledge source may be modelled as a mutable knowledge asset  because of the possibility of correction of existing contents without a change of identifier. The modular nature of legal codes -- chapters, sections, acts -- is amenable to Set- or List-tree structures. Although some aspects, such as the addition of new rules, would fit with the Stream structure, queries are not expected to produce streaming results, and so the mutable asset model is a better fit than a Stream-based model.

\item The model of the emergency response system makes use of the Try monad, so that results can be reported as Success or Failure. A Success response has a value with the requested query results or confirmation of the update as a description. A Failure response includes information about the nature of the failure (e.g. timeout exception) so that the system can recover appropriately.

\end{enumerate}

Our further use case implementations address, e.g., explicit state management and concurrency in sports competitions \cite{JefferyKP09}. In a distributed, two-stage design a functional state transformer component works together with a typical stream processor composed of operators (event processing agents) using a functional message-passing style for the communication between the two. In the first stage the state transformer (ST) is responsible for explicit state management, concurrency control, reasoning (specifically, inference of state deltas), and state updates. In the second stage a stream processor (SP) is used for event pattern detection and emission of derived events, where the SP is responsible for augmenting the state deltas with detected event patterns that ST then includes in the updated state. 

%\subsection{Java Implementation of API4KP}

The monad laws have been verified experimentally for SetTree and ListTree monads by implementation in Java8 together with the Functional Java libraries, with the source available on Github\footnote{\url{https://github.com/ag-csw/Java4CL}}. Informal tests confirm that the map and join operations are linear in the size of the collection, as expected.

%\subsection{Prova API4KP mapping}

%Prova functional programming supports:
%
%\begin{itemize}
%  \item single- and multi-valued functions, the latter offering direct support for non-determinism and backtracking;
%  \item functional composition with the extended derive built-in;
%  \item partial evaluation;
%  \item lambda functions;
%  \item monadic functions;
%  \item monadic bind using a composition of map and join;
%  \item maybe, list, state, fact, and tree monads as part of the provided library with easy extensibility;
%  \item combination of monads;
%  \item stream fusion capability.
%\end{itemize}
%
%Prova offers two mechanisms for composing functions: simple composition and monadic composition. In the case of simple composition, the functional pipeline is composed of functions operating on the totality of the values being passed between them. In the case of monadic composition, the functional pipeline passes around monadic data and is composed of functions operating on data in some form "contained" in the monadic data. Monadic composition in Prova is done by pattern-matching the data passed between functions in the functional pipeline.
%Monads supported are Maybe monad,  List monad, State monad, Fact monad. Additionally, the stream fusion technique in Prova allows one to write functional pipelines the usual way but fuse the transformations and execute them iteratively, producing one final result at a time. A special built-in predicate \textit{derive} is used for executing functional pipelines. The functional flavor of derive takes a single parameter, which is a Prova list with exactly three elements:
%\begin{itemize}
%  \item functional pipeline,
%  \item input,
%  \item output.
%\end{itemize}


\section{Related Work and Discussion}
%TBD


%discussion of approaches for handling state and concurrency for operations on mutable knowledge resources

%State Monads \cite{LaunchburyJ95} are used in purely functional programming language such as Haskell \cite{PeytonJ2003} to express functions which exist within the context of another computation or transformation, thus allowing the programmer to attach state information to any kind of functional expression. Concurrent clean uses uniqueness typing \cite{Plasmeijer1998} to allow destructive update of state in pure functional code. Functional Reactive Programming (FRP) \cite{WanH00} is another approach to event-driven functional programming. Mercury \cite{Mercury15} provides 'state variables' as a simple syntactic shorthand for naming intermediate state values in a sequence. Software Transactional Memory (STM) \cite{JonesS2007}, proposes a type-based approach to encapsulating transactional updates in functions evaluated on special transactional variables. Any such computation becomes atomic and the type system prevents direct access to such variables. Actor models of concurrency \cite{Agha90} such as in Erlang or Scala Akka \cite{Akka2015} introduces actors as distributed autonomous interacting components that have their own identity, mutable state, functions updating that state, and thread of control. Prova \cite{Prova2012} uses a refinement of actor implementations with functional reactive programming and monadic functions. The functional stream fusion technique in Prova allows one to write functional pipelines the usual way but fuse the transformations and execute them iteratively, producing one final result at a time. Prova allows for parallel computation performed in a separate pool or on distributed computation resources. It also distinguish between cycled event processing that is strictly sequential and blocks processing of the new raw events before the system is finished with the previous event, and processing of responses to nested computations that are also accepted on the same (actor) thread but whose processing order is non-deterministic. 
%Other approaches to explicit handling of state, e.g., in stream processing products, accumulated state in special variables or tuples that are available either locally to an individual operator or across the operators as a shared storage. Or provide special extension points that allows state and control to be encapsulated in procedural code associated with the operators (e.g. Aleri FlexStream \cite{Aleri2008}). Database solutions, such as Orcale CEP \cite{Oracle2008} or Streambase, provide query tables and relations, respectively, that keep the state in the form of tuples. 

%OWL Specification - ontology series
%RDF Specification - RDF source
%OBDA and RBDA

The API4KP metamodel introduces the following generalizations of OntoIOp/DOL concepts:
\begin{itemize}
\item Knowledge sources can have different levels of abstraction. DOL's OMS concept correspond to knowledge expressions, while we consider also the levels of asset, manifestation and item.
\item Knowledge sources can be mutable or immutable. DOL's OMS correspond to immutable knowledge expressions.
\item Each API4KP knowledge asset is conceptualized according to a customizable environment, instead of assuming a single logical environment in which all OMS are interpreted.
\item Environment members can be any language with an abstract syntax, instead of requiring each member to have a specific semantics. Only the focus of the environment is required to have its own semantics.
\item Semantics is generalized to include side-effects as well as logical entailment.
\item Structured knowledge resources may have structures other than nested sets.
\end{itemize}

The variety of monad structures necessary to model the diversity of usecases demonstrates that a high level of abstraction is needed to define "universal" operations for modifying knowledge resources - adding, subtracting or modifying in place. Category theory provides the tools for these abstractions, through applicative functors (a generalization of monads having a binary operator allowing a structure of functions to be applied to another structure), catamorphisms (generalization of aggregation over a list to other monads) and anamorphisms (e.g. generation of a list from a seed and recursion formula).

The Kleisli Query System \cite{Wong2000} has implemented a similar approach for data computations.

\section{Conclusion and Future Work}
\label{conc}
The primary contributions of this paper are two-fold:
\begin{itemize}
\item the upper levels of a metamodel for descriptions of knowledge sources and knowledge operations
\item a generic monadic tree structure derived from other monads, as the conceptual basis of structured knowledge resources
\end{itemize}
We have provided a proof-of-concept of this conceptual framework by application to the usecases, and prototypical implementations.
%and proof for the monadic tree structure.

Future work on API4KP may include:
\begin{itemize}
\item generalization of approach to include structures based on applicative functors, and
operations in terms of catamorphisms and anamorphisms
\item population of the ontology with specifications of additional operations, especially querying and life-cycle management
\end{itemize}

%\section{Appendix}

%Proof of satisfaction of monad laws by M-trees
% Note - a shorter proof could probably be obtained using Kleisli's
%[Functor Identity] map(id)(y) = y
%To verify the Functor Identity law for an M-tree, it is sufficient to show that map$_N$(id) = id. 
%In terms of the definition of map$_N$, 
%$$ map_N(f) = map_M( bimap(f, map_N(f)) ) $$
%we must show
%$$ map_N(id) = map_M( bimap(id, map_N(id)) ) = id $$
%If x is Left, then bimap(id, _)(x) = (x), so the law holds in the base case.
%Now suppose x is Right and the law holds for the components of x.
%Then the law also holds for x. Because M-trees are finite, then %the law holds by induction.
%
%
%where bimap takes two functions, applying the first if the Either is Left, the second if the Either is Right.
%[Functor Associativity] map(f o g) = map(f) o map(g)
%where id is identity function s $\Rightarrow$ s.
%[Unit from Natural Transformation] map(f)(unit(x)) = unit(f(x))
%[Join from Natural Transformation] join(map(join)(x)) = join(join(x))

%[Monad Left Identity] join(map(unit)(x)) = x
%[Monad Right Identity] join(unit(x)) = x
%[Monad Associativity] join(map(map(f))(x)) = map(f)(join(x))

\bibliographystyle{splncs03}
\bibliography{api4kbonto}

\end{document}
